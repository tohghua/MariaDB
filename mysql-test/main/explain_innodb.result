#
# MDEV-26249: Crash in in Explain_node::print_explain_for_children while writing to the slow query log
#
set @sql_tmp=@@slow_query_log;
SET GLOBAL slow_query_log = 1;
SET long_query_time = 0.000000;
SET log_slow_verbosity = 'explain';
CREATE TABLE t1 ( id varchar(50), KEY (id)) engine=innodb;
SELECT * FROM (SELECT id FROM t1 GROUP BY id) dt WHERE 1=0;
id
select 1;
1
1
explain
SELECT * FROM (SELECT id FROM t1 GROUP BY id) dt WHERE 1=0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
2	DERIVED	t1	range	NULL	id	53	NULL	2	Using index for group-by
SET GLOBAL slow_query_log = @sql_tmp;
drop table t1;
#
# End of 10.4 tests
#
#
# MDEV-33752: EXPLAIN UPDATE acquires locks on table rows
#
create table t1 (
id BIGINT(19) NOT NULL,
id2 BIGINT(19) NOT NULL,
b tinyint(1) default 0,
PRIMARY KEY (id, id2),
UNIQUE KEY (id)
) engine=innodb;
create table t2 (
id BIGINT(19) NOT NULL,
b tinyint(1) default 0,
PRIMARY KEY (id)
) engine=innodb;
insert into t1 values (1,11,0),(3,13,0),(4,14,0),(5,15,0);
insert into t2 values (1,0),(3,0),(4,0),(5,0);
connect  con1,localhost,root,,;
connection con1;
set autocommit = 0;
set session transaction isolation level repeatable read;
explain update t2 set b=1 where id = (select id from t1 where id2 in (11));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	range	PRIMARY	PRIMARY	8	NULL	1	Using where
2	SUBQUERY	t1	index	NULL	PRIMARY	16	NULL	4	Using where; Using index
# Check that we hold on to MDL locks:
select LOCK_MODE, LOCK_TYPE, TABLE_SCHEMA, TABLE_NAME from information_schema.metadata_lock_info;
LOCK_MODE	LOCK_TYPE	TABLE_SCHEMA	TABLE_NAME
MDL_SHARED_READ	Table metadata lock	test	t1
MDL_SHARED_READ	Table metadata lock	test	t2
connection default;
# Check that we don't hold row locks (if we did, this would hang) :
begin;
insert into t1 values (2,12,0);
rollback;
connection con1;
# Now, run the UPDATE, not EXPLAIN:
update t2 set b=1 where id = (select id from t1 where id2 in (11));
# And check that it has acquired the locks. Now, INSERT will wait on the lock:
connection default;
insert into t1 values (2,12,0);
# Verify it's waiting
connection con1;
# Check what the INSERT is waiting on:
select lock_type, lock_table, lock_mode, lock_index from information_schema.innodb_locks;
lock_type	lock_table	lock_mode	lock_index
RECORD	`test`.`t1`	X,GAP	PRIMARY
RECORD	`test`.`t1`	S	PRIMARY
rollback;
disconnect con1;
connection default;
drop table t1, t2;
